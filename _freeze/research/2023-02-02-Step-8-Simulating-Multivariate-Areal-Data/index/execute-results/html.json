{
  "hash": "95478476b9c5c46116c810f7ffaa1a53",
  "result": {
    "markdown": "---\ntitle: \"Step 8 - Simulating Multivariate Areal Data\"\ndescription: \"We show how to simulate multivariate areal data with spatial dependence using the CAR model.\"\nauthor:\n  - name: Matthew Shisler\n    affiliation: North Carloina State University - Department of Statistics\n    affiliation-url: https://statistics.sciences.ncsu.edu/ \ncategories: [Bayesian, MCMC, Spatial, CAR] # self-defined categories\ndraft: false \nformat:\n  html: \n    code-fold: true\nexecute: \n  cache: false\n  freeze: auto\n---\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Code: Load the packages\"}\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(viridis)\n```\n:::\n\n\n## Intro\n\nWe are going to examine the spatial CAR model in the context of the land surface phenology problem.\n\nConsider a spatial domain $\\mathcal{D}$ partitioned into a regular lattice of areal units $s \\in \\mathcal{D}$. Then, for a single year, each areal unit will have associated with it a \"greenness\" curve that is a description of that areal unit's land surface phenology over the course of the year. The true greenness curve is the object of study. We observe the curve at only a finite number of points according to the capabilities of the collecting satellite. The goal is to recover this curve from these finite points.\n\nWe model this greenness curve with the so called \"double-logistic\" function, $\\nu(t,\\boldsymbol\\theta)$, a function of time that is parameterized by the vector $\\boldsymbol\\theta = (\\theta_1,\\dots,\\theta_p)$. Here, $p = 7$. Note: link to previous post mentioning $\\nu$.\n\nIt is difficult to identify the double-logistic function best characterizing the greenness curve for a single site and single year in isolation due to a paucity of data. Such an approach also neglects the spatial dependence across sites in the domain.\n\nInstead, we should draw information from other observations that are adjacent in either space or time (on a year-to-year scale).\n\nFor now, let's consider modeling the spatial dependence. Fix ourselves to a snapshot in time, a single year, and consider the spatial domain $\\mathcal{D}$ described above. Suppose that in some earlier stage of the analysis, data was aggregated to allow for a estimate to be made for $\\boldsymbol\\theta$ which we will refer to as $\\boldsymbol\\theta_{\\mathcal{D}}$. The result is a \"region mean\".\n\n## A basic simulation\n\nIn this example, we abstract away the data layer of the model and focus on the \"deviation parameters\", $\\delta_{sj}$.\n\nRecall that $\\delta_{sj}$ is a scalar parameter describing the deviation of the $j$th parameter at location $s$ from the regional average model, $(\\boldsymbol\\theta_{\\mathcal{D}})_j$. This is a product of the linearization of the double-logistic function with respect to $\\boldsymbol\\theta$.\n\nWe will arrange these parameters into vectors in a few different ways. First, let $\\boldsymbol\\delta_s$ be the $p \\times 1$ vector of parameters associated with location $s \\in \\mathcal{D}$. Here $\\boldsymbol\\delta_s$ describes the deviation of the entire phenology curve at location $s$ from the regional average phenology curve. Next, let $\\boldsymbol\\delta_{\\cdot j}$ be the $n \\times 1$ vector of the $j$th parameter from $\\boldsymbol\\delta_s$ for all $s = 1,\\dots,n$.\n\nLet the spatial domain be a regular square lattice with $n=25$ areal units.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn      <- 5\nnsites <- n^2\nspat_domain <- expand.grid(x = 1:n, y = 1:n)\nspat_domain$label <- 1:(n*n)\nspat_domain_g <- make_lattice(c(n,n), mutual = TRUE)\nW <- as.matrix(as_adjacency_matrix(spat_domain_g, sparse=1))\nM <- diag(rowSums(W))\n\nggplot(spat_domain) +\n  geom_tile(aes(x, y), linewidth = 2, color = \"grey50\", fill=\"white\") +\n  geom_text(aes(x, y, label=label), size = 15) +\n  coord_fixed() + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n \nFirst, we sample $\\boldsymbol\\delta_{\\cdot j}$ from a univariate CAR model for each $j = 1,\\dots,p$. Let $\\mathbf{W}$ be the proximity matrix defining the neighbor sites of each site, $\\mathbf{M}$ be a diagonal matrix where the diagonal contains the number of neighboring sites, $\\rho$ be a parameter controlling the strength of spatial association, and $\\tau^2_j$ be [insert interpretation]. Note that $\\rho$ is shared across the $j$ elements and $\\tau^2_j$ is specific to the $j$th element of $\\boldsymbol\\delta_s$.\n \n$$\n\\boldsymbol\\delta_{\\cdot j} \\sim \\text{N}(\\boldsymbol0, \\tau_j^2(\\mathbf{M}-\\rho\\mathbf{W})^{-1})\n$$\n\nThis induces spatial dependence independently for each $j$ element of $\\boldsymbol\\delta_s$.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Code: univariate CAR samples\"}\np    <- 7\ntau2 <- c(1,1,1,1,1,1,1)\nrho  <- 0.99\nspat_re <- matrix(NA, nrow = nsites, ncol = p)\n\nfor (i in 1:p){\n  spat_prec   <- (1/tau2[i])*(M-rho*W)\n  spat_domain[, ncol(spat_domain) + 1] <- backsolve(chol(spat_prec), \n                                                    matrix(rnorm(nsites), \n                                                           nrow = nsites))\n  colnames(spat_domain)[ncol(spat_domain)] <- paste0(\"phi\", i)\n}\n\nspat_domain <- gather(spat_domain, key = \"phi\", value = \"value\", -c(x,y,label))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(spat_domain) +\n  geom_tile(aes(x, y, fill=value)) +\n  scale_fill_gradientn(colors = viridis(10)) +\n  coord_fixed() +  \n  theme_void() +\n  facet_wrap(~phi)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nI'm thinking this might not be a great idea. . . shouldn't we expect the spatial patterns to be related somehow? Yes, I think so. . , but I believe this will require either the matrix normal distribution or a very large kronecker product.\n\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}