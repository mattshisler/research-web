{
  "hash": "d49d52b6f4ebdabcafc49cf4bd0e5474",
  "result": {
    "markdown": "---\ntitle: \"Step 5 - Verify Convergence\"\ndescription: \"Here we initialize the sampler with different values and check if the chains converge to the same stationary distribution.\"\nauthor:\n  - name: Matthew Shisler\n    affiliation: North Carloina State University - Department of Statistics\n    affiliation-url: https://statistics.sciences.ncsu.edu/ \ncategories: [Bayesian, MCMC, Hierarchical Model] # self-defined categories\ndraft: false \nformat:\n  html: \n    code-fold: true\nexecute: \n  cache: true\n  freeze: auto\n---\n\n::: {.cell hash='index_cache/html/load-packages_20393ab02cca7f43d0ba6312721af7c1'}\n\n```{.r .cell-code  code-summary=\"Code: Load the packages\"}\nlibrary(tictoc)\nlibrary(Rfast)\nlibrary(numDeriv)\n```\n:::\n\n\nThe goal here will be to verify convergence of the MCMC developed in the previous steps. First, we'll define the functions necessary to fit the model.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-2_d07e9302eea144abfafe998c1ae6a667'}\n\n```{.r .cell-code  code-summary=\"User-defined functions\"}\n# expit #\n# equivalent to plogis with m=0 & s=1.\nexpit   <- function(x){1/(1+exp(-x))}\n\n# expit_p #\n# first derivative of the expit function. equivalent to dlogis with m=0 & s=1.\nexpit_p <- function(x){expit(x)*(1-expit(x))}\n\n\ndouble_logis <- function(t, theta){\n  # double logistic function.\n  # theta1 is transformed using the logistic function.\n  # theta2 is transformed using the \n  # This allows for all parameters to follow a gaussian distribution\n  \n  theta[1] <- plogis(theta[1])\n  theta[7] <- exp(theta[7])  \n  \n  n1 <- 1\n  d1 <- 1 + exp((theta[3] - t)/theta[4])\n  \n  n2 <- 1\n  d2 <- 1 + exp((theta[5] - t)/theta[6])\n  \n  out <- theta[1] + (theta[2] - theta[7]*t)*(n1/d1 - n2/d2)\n  \n  return(out)\n}\n\n# double logistic gradient wrt theta\nbasis_functions <- function(t,theta){\n  t   <- t%%366\n  \n  dl0 <- double_logis(t,theta)-expit(theta[1])\n  a <- expit_p(theta[7])\n  theta[7] <- exp(theta[7])\n  \n  B1 <- expit_p(theta[1])\n  B2 <- (1/(1+exp((theta[3]-t)/theta[4])))-(1/(1+exp((theta[5]-t)/theta[6])))\n  B3 <- (theta[7]*t - theta[2])/(2*theta[4]*cosh((theta[3]-t)/theta[4])+2*theta[4])\n  B4 <- ((theta[3] - t)*(theta[2]-theta[7]*t)*cosh((theta[3]-t)/(2*theta[4]))^(-2))/(4*theta[4]^2)\n  B5 <- (theta[2] - theta[7]*t)/(2*theta[6]*cosh((theta[5]-t)/theta[6])+2*theta[6])\n  B6 <- ((theta[5] - t)*(theta[7]*t-theta[2])*cosh((theta[5]-t)/(2*theta[6]))^(-2))/(4*theta[6]^2)\n  B7 <- -t*a*((1/(1+exp((theta[3]-t)/theta[4])))-(1/(1+exp((theta[5]-t)/theta[6]))))\n  B <- unname(cbind(B1, B2, B3, B4, B5, B6, B7))\n  \n  return(B)\n}\n\nfit_lm <- function(Y, X, Z,      \n                   delta, sigma2,                     \n                   beta, Omega,                 \n                   mu, Lambda,                      \n                   a, b,                        \n                   niter = 5000){\n  \n  require(Rfast)\n  \n  # indexes\n  p <- dim(delta)[1]\n  q <- dim(Z)[2]\n  N <- dim(delta)[2]\n  n <- sapply(Y, length)\n  \n  # unstack beta\n  B <- matrix(c(beta), nrow=p)\n  Lambda_inv <- diag(1/diag(Lambda))\n  \n  # storage\n  keep_delta  <- array(NA, dim = c(p, N, niter))\n  keep_B      <- array(NA, dim = c(p, q, niter))\n  keep_Omega  <- matrix(NA, nrow = niter, ncol = p)\n  keep_sigma2 <- rep(NA, niter)\n  \n  # set initial values\n  keep_delta[,,1] <- delta\n  keep_B[,,1]     <- B\n  keep_Omega[1,]  <- diag(Omega)\n  keep_sigma2[1]  <- sigma2\n  \n  # pre-computes\n  XtX <- list()\n  XtY <- list()\n  for (k in 1:N){\n    XtX[[k]] <- t(X[[k]])%*%X[[k]]\n    XtY[[k]] <- t(X[[k]])%*%Y[[k]]\n  }\n  ZtZ <- t(Z)%*%Z\n  Lmu <- Lambda_inv%*%mu\n  Ao    <- N/2 + a\n  As    <- sum(n)/2 + a\n  \n  # Gibbs Loop\n  tik <- proc.time()\n  for (iter in 2:niter){\n    \n    Omega_inv <- diag(1/diag(Omega))\n    \n    # sample deltas\n    for (i in 1:N){\n      M         <- (1/sigma2)*XtY[[i]] + Omega_inv%*%(B%*%Z[i,])\n      V_inv     <- chol2inv(chol((1/sigma2)*XtX[[i]] + Omega_inv))\n      delta[,i] <- V_inv%*%M+t(chol(V_inv))%*%rnorm(p)\n    }\n    \n    # sample beta\n    M     <- kronecker(t(Z), Omega_inv)%*%matrix(c(delta), ncol = 1) + Lmu\n    V_inv <- solve(kronecker(ZtZ, Omega_inv) + Lambda_inv)\n    beta  <- V_inv%*%M+t(chol(V_inv))%*%rnorm(q*p)\n    B     <- matrix(beta, nrow = p)\n    \n    # sample omegas\n    for (k in 1:p){\n      Bo <- sum((delta[k,] - (B%*%t(Z))[k,])^2)/2 + b\n      Omega[k,k] <- 1/rgamma(1, Ao, Bo)\n    }\n    \n    # sample sigma2\n    SSE <- 0\n    for (i in 1:N){\n      SSE <- SSE + sum((Y[[i]] - X[[i]]%*%delta[,i])^2)\n    }\n    Bs <- SSE/2 + b\n    sigma2 <- 1/rgamma(1, As, Bs)\n    \n    # store everything\n    keep_delta[,,iter] <- delta\n    keep_B[,,iter]     <- B\n    keep_Omega[iter,]  <- diag(Omega)\n    keep_sigma2[iter]  <- sigma2\n  }\n  tok <- proc.time() - tik\n  \n  return(list(keep_delta = keep_delta, \n              keep_B = keep_B, \n              keep_Omega = keep_Omega, \n              keep_sigma2 = keep_sigma2, \n              comp_time = tok))\n}\n```\n:::\n\n\nWe'll start by simulating some data similar to that in Step 4, then initialize the Gibbs sampler at different values to confirm the chains converge to the same stationary distribution.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-3_996255200045c5355244e872cfb634e0'}\n\n```{.r .cell-code  code-summary=\"Simulate the data\"}\n# dimensions\nN <- 40\nm <- 366\nn <- rep(100,N)\np <- 7\nq <- 2\n\ntheta0 <- c(-1.80, 0.75, 120, 8, 270, 8, -7.5)\n\n# Design matrices\ngradinput <- function(x,t){\n  return(double_logis(t,x))\n}\n\n# compute numerical gradient\nXp <- basis_functions(1:366, theta0)\nZ  <- matrix(c(rep(1,N), seq(1:N)), ncol = 2)\n\n# beta parameters\nB0     <- matrix(c(0, 0, -15, 0, 15, 0, 0,\n                   0, 0,   1, 0, -1, 0, 0), nrow=p)\nbeta0  <- matrix(c(B0), ncol = 1)\nOmega0 <- diag(c(0.025, 1e-3,  3, 1,  3, 1, 0.0005))\n\n# delta parameters\ndelta0  <- matrix(0, nrow = p, ncol = N)\nsigma20 <- 0.0025\n\n# sample data\nY <- list()\nX <- list()\nt <- list()\nfor (i in 1:N){\n  # draw delta\n  delta0[,i]   <- t(Rfast::rmvnorm(1, B0%*%Z[i,], Omega0))\n  \n  # draw rows from parent X\n  t[[i]] <- sample(1:m, n[i])\n  X[[i]] <- Xp[t[[i]],]\n  \n  # draw response\n  Y[[i]] <- matrix(rnorm(n[i], mean = X[[i]]%*%delta0[,i], sd = sqrt(sigma20)), ncol=1)\n}\n```\n:::\n\n\nFit model with first set of initial values.\n\n::: {.cell hash='index_cache/html/unnamed-chunk-4_adad95ee75acceee76f27a6cd4d978b3'}\n\n```{.r .cell-code  code-summary=\"Fit model 1\"}\nniter  <- 5000\ndelta  <- matrix(0, nrow = p, ncol = N)\nbeta   <- rep(0, q*p)\nsigma2 <- 0.01\nOmega  <- diag(c(0.5, 0.5, 5, 0.5, 5, 0.5, 0.001))\n\nmu     <- rep(0, q*p)\nLambda <- diag(rep(1e06,q*p))\na      <- 0.1\nb      <- 0.1\n\nfit1 <- fit_lm(Y, X, Z,\n               delta, sigma2,\n               beta, Omega,\n               mu, Lambda,\n               a, b,\n               niter = niter)\n```\n:::\n\n\nFit model with second set of initial values.\n\n::: {.cell hash='index_cache/html/unnamed-chunk-5_96ca0bc9fa14ca31b5a1f198272e68ce'}\n\n```{.r .cell-code  code-summary=\"Fit model 2\"}\ndelta  <- matrix(10, nrow = p, ncol = N)\nbeta   <- rep(10, q*p)\nsigma2 <- 2\nOmega  <- 2*diag(p)\n\nmu     <- rep(0, q*p)\nLambda <- diag(rep(1e06,q*p))\na      <- 0.1\nb      <- 0.1\n\nfit2 <- fit_lm(Y, X, Z,\n               delta, sigma2,\n               beta, Omega,\n               mu, Lambda,\n               a, b,\n               niter = niter)\n```\n:::\n\n\nFit model with third set of initial values.\n\n::: {.cell hash='index_cache/html/unnamed-chunk-6_a724a8673ed69894d971fd62828ddf78'}\n\n```{.r .cell-code  code-summary=\"Fit model 3\"}\ndelta  <- matrix(-10, nrow = p, ncol = N)\nbeta   <- rep(-10, q*p)\nsigma2 <- 3\nOmega  <- diag(p)\n\nmu     <- rep(0, q*p)\nLambda <- diag(rep(1e06,q*p))\na      <- 0.1\nb      <- 0.1\n\nfit3 <- fit_lm(Y, X, Z,\n               delta, sigma2,\n               beta, Omega,\n               mu, Lambda,\n               a, b,\n               niter = niter)\n```\n:::\n\n\nNext we'll construct the trace plots of the parameters from each of the three models. Convergence to the same stationary distribution will be apparent if the chains merge together.\n\nFirst for $\\boldsymbol\\beta$.\n\n::: {.cell hash='index_cache/html/unnamed-chunk-7_385719a47387f1307005e4eb471a0f2e'}\n\n```{.r .cell-code  code-summary=\"Construct trace plots\"}\nwin <- 100:niter\n\nymin <- c(-2, -2, -25, -10, -5, -10, -5)\nymax <- c( 2,  2,   5,  10, 20,  10,  5)\n\npar(mfrow = c(2,2))\n\nfor(l in 1:q){\n  for (k in 1:p){\n    # ymin <- min(fit1$keep_B[k, l, win], fit2$keep_B[k, l, win], fit3$keep_B[k, l, win])\n    # ymax <- max(fit1$keep_B[k, l, win], fit2$keep_B[k, l, win], fit3$keep_B[k, l, win])\n    plot(win, fit1$keep_B[k, l, win], type = \"l\",\n         ylab = bquote(beta[paste(.(l),\",\",.(k))]),\n         xlab = \"iter\",\n         ylim = c(ymin[k], ymax[k]))\n    lines(win, fit2$keep_B[k, l, win], col =\"blue\")\n    lines(win, fit3$keep_B[k, l, win], col =\"green\")\n    abline(h = B0[k, l], col = \"red\", lwd = 2)\n  }\n}\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-4.png){width=672}\n:::\n:::\n\n\n\nTrace plots for $\\boldsymbol\\Omega$.\n\n::: {.cell hash='index_cache/html/unnamed-chunk-8_30fcdefb8633787a886a0e72e04db88f'}\n\n```{.r .cell-code}\npar(mfrow = c(2,2))\n\nymin <- 0\nymax <- c(0.1, 0.02, 10, 6, 8, 6, 0.3)\n\nfor (k in 1:p){\n  plot(win, fit1$keep_Omega[win, k], type = \"l\",\n       ylab = bquote(omega[paste(.(k),\",\",.(k))]),\n       xlab = \"iter\",\n       ylim = c(ymin, ymax[k]))\n  lines(win, fit2$keep_Omega[win, k], col =\"blue\")\n  lines(win, fit3$keep_Omega[win, k], col =\"green\")\n  abline(h = Omega0[k, k], col = \"red\",lwd = 3)\n}\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-2.png){width=672}\n:::\n:::\n\n\nTrace plots for $\\sigma^2$\n\n::: {.cell hash='index_cache/html/unnamed-chunk-9_97e3008d290a7557191545603f0862e3'}\n\n```{.r .cell-code}\nplot(win, fit1$keep_sigma2[win], type = \"l\",\n     ylab = bquote(sigma^2),\n     xlab = \"iter\")\nlines(win, fit2$keep_sigma2[win], col =\"blue\")\nlines(win, fit3$keep_sigma2[win], col =\"green\")\nabline(h = sigma20, col = \"red\", lwd = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nTrace plots for 5 subject $\\boldsymbol\\delta_i$ chosden at random.\n\n::: {.cell hash='index_cache/html/unnamed-chunk-10_0c3390a4c7821430769b88d834ba0d5a'}\n\n```{.r .cell-code}\nwin <- 1:niter\n\npar(mfrow = c(2,2))\nparam_sample <- sample(1:N, 5)\n\nfor (year in param_sample){\n  for (k in 1:p){\n    subscr <- paste0(year,\",\",k)\n    plot(win, fit1$keep_delta[k, year, win], type = \"l\",\n         ylab = bquote(delta[.(subscr)]),\n         xlab = \"iter\")\n    lines(win, fit2$keep_delta[k, year, win], col =\"blue\")\n    lines(win, fit3$keep_delta[k, year, win], col =\"green\")\n    abline(h = delta0[k, year], col = \"red\")\n  }\n}\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-4.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-5.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-6.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-7.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-8.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-9.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}