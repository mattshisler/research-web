{
  "hash": "f44be45e004f68763974c65448c741f9",
  "result": {
    "markdown": "---\ntitle: \"Step 2 - One Parent Design Matrix\"\ndescription: \"Here we extend to the situation of one parent design matrix from which rows are drawn to construct design matrices for each response vector.\"\nauthor:\n  - name: Matthew Shisler\n    affiliation: North Carloina State University - Department of Statistics\n    affiliation-url: https://statistics.sciences.ncsu.edu/ \ncategories: [Bayesian, MCMC, Hierarchical Model] # self-defined categories\ndraft: false \nformat:\n  html: \n    code-fold: true\nexecute: \n  cache: true\n  freeze: auto\n---\n\n::: {.cell hash='index_cache/html/load-packages_33d89cbae04dd9557210b6bf96e1061f'}\n\n```{.r .cell-code  code-summary=\"Code: Load the packages\"}\nlibrary(tictoc)\nlibrary(Rfast)\n```\n:::\n\n\nThe setting is the same as in step 1 only now we will generate a single \"parent\" design matrix, $\\mathbf{X}$, which is $m \\times p$ and $m \\ge n_i$ for all $i$. That is to say we can't have more rows in a subject's design matrix than the parent matrix. To implement this we will generate the parent design matrix, then sample $n_i$ integers from the sequence $1,\\dots, m$ and extract the corresponding rows of $\\mathbf{X}$ to construct a subject's design matrix, $\\widetilde{\\mathbf{X}}_i$.\n\nThe parameters $\\boldsymbol\\delta_i$ are drawn from a multivariate normal random effects distribution with mean $\\beta$ and covariance $\\mathbf{\\Omega}$. The entries of $\\mathbf{Y}_i$ are mutually independent with constant variance $\\sigma^2$, $\\text{Cov}(\\mathbf{Y}_i) = \\sigma^2 \\mathbf{I}_n$ for all $i$. Further, $\\mathbf{Y}_1,\\dots,\\mathbf{Y}_N$ are mutually independent.\n\n\\begin{align*}\n\\mathbf{Y}_i &\\sim \\text{Normal}_{n_i}\\left(\\widetilde{\\mathbf{X}}_i\\boldsymbol\\delta_i, \\; \\sigma^2 \\mathbf{I}_{n_i}\\right)\\\\\n\\boldsymbol\\delta_i &\\sim \\text{Normal}_p\\left(\\boldsymbol\\beta, \\; \\mathbf{\\Omega}\\right)\n\\end{align*}\n\nIn this case we will assume $\\mathbf{\\Omega}$ is diagonal and let $\\omega_{kk}$ be the $k$th diagonal element. Next specify priors,\n\\begin{align*}\n\\boldsymbol\\beta &\\sim \\text{Normal}_p\\left(\\boldsymbol\\mu, \\; \\mathbf{\\Lambda}\\right)\\\\\n\\omega_{kk} &\\sim \\text{InvGamma}\\left(a_{k}, \\; b_{k} \\right)\\\\\n\\sigma^2 &\\sim \\text{InvGamma}\\left(a, \\; b\\right)\n\\end{align*}\n\nNote, for simplicity there is no linear trend in the random effects distribution for $\\boldsymbol\\delta_i$. Also, I've left its covariance to be diagonal, just to avoid the Inverse Wishart prior for now. This way we can update the diagonal elements of $\\mathbf{\\Omega}$ individually.\n\nThe full conditionals in this model are. . . \n\n\\begin{align*}\n\\boldsymbol\\delta_i|\\text{ rest} &\\sim \\text{Normal}_p(\\mathbf{V}_i^{-1}\\mathbf{M}_i, \\mathbf{V}_i^{-1})\\\\\n\\mathbf{V}_i &= \\frac{1}{\\sigma^2} \\widetilde{\\mathbf{X}}_i^T\\widetilde{\\mathbf{X}}_i + \\mathbf{\\Omega}^{-1}\\\\\n\\mathbf{M}_i &= \\frac{1}{\\sigma^2} \\widetilde{\\mathbf{X}}_i^T\\mathbf{Y}_i + \\mathbf{\\Omega}^{-1}\\boldsymbol\\beta\\\\\\\\\n\\boldsymbol\\beta|\\text{ rest} &\\sim \\text{Normal}_p(\\mathbf{V}_\\beta^{-1}\\mathbf{M}_\\beta, \\mathbf{V}_\\beta^{-1})\\\\\n\\mathbf{V}_\\beta &= N\\mathbf{\\Omega}^{-1} + \\mathbf{\\Lambda}^{-1}\\\\\n\\mathbf{M}_\\beta &= \\mathbf{\\Omega}^{-1}\\sum_{i=1}^N\\boldsymbol\\delta_i + \\mathbf{\\Lambda}^{-1}\\boldsymbol\\mu\\\\\\\\\n\\omega_{kk}|\\text{ rest} &\\sim \\text{InvGamma}(A_k,B_k)\\\\\nA_k &= N/2 + a_k\\\\\nB_k &= \\frac{1}{2}\\sum_{i=1}^N (\\delta_{ik} - \\beta_k)^2 + b_k\\\\\\\\\n\\sigma^2|\\text{ rest} &\\sim \\text{InvGamma}(A,B)\\\\\nA &= \\frac{1}{2}\\sum_{i=1}^N n_i + a\\\\\nB &= \\frac{1}{2}\\sum_{i=1}^N (\\mathbf{Y}_i - \\widetilde{\\mathbf{X}}_i\\boldsymbol\\delta_i)^T(\\mathbf{Y}_i - \\widetilde{\\mathbf{X}}_i\\boldsymbol\\delta_i) + b\n\\end{align*}\n\n\nSimulate some data from this model. In this case will we set $N = 100$, $p = 2$, $n_i = n = 100$, and $m = 400$. \n\n::: {.cell hash='index_cache/html/unnamed-chunk-2_b3461241d476b5c512adbc7aab248ef2'}\n\n```{.r .cell-code  code-summary=\"Simulate the data\"}\nm <- 400\nN <- 100\np <- 2\nn <- rep(100, N)\n\nXp <- matrix(c(rep(1,m), rnorm(m*(p-1), mean = 0, sd = 5)), nrow = m, ncol = p)\n\nbeta0  <- rnorm(p, mean = 0, sd = 5)\nOmega0 <- diag(c(2,1))\n\ndelta0  <- t(Rfast::rmvnorm(N, beta0, Omega0))\nsigma20 <- 1\n\nY <- list()\nX <- list()\nfor (i in 1:N){\n  subject_rows <- sample(1:m, n[i])\n  X[[i]] <- Xp[subject_rows,]\n  Y[[i]] <- matrix(rnorm(n[i], mean = X[[i]]%*%delta0[,i], sd = sqrt(sigma20)), ncol=1)\n}\n```\n:::\n\n\nThe Gibbs sampler is identical to that found in Step 1.\n\n::: {.cell hash='index_cache/html/unnamed-chunk-3_a244152bed9cae604ad8fa67253c4149'}\n\n```{.r .cell-code  code-summary=\"Run the Gibbs Sampler\"}\n# set-up\nniter <- 5000\nkeep_delta  <- array(NA, dim = c(p, N, niter))\nkeep_beta   <- matrix(NA, nrow = niter, ncol = p)\nkeep_Omega  <- matrix(NA, nrow = niter, ncol = p)\nkeep_sigma2 <- rep(NA, niter)\n\n# initial values\ndelta  <- matrix(0, nrow = p, ncol = N)\nbeta   <- rep(10, p)\nsigma2 <- 3\nOmega  <- diag(c(5,5))\nkeep_delta[,,1] <- delta\nkeep_beta[1,]   <- beta\nkeep_Omega[1,]  <- diag(Omega)\nkeep_sigma2[1]  <- sigma2\n\n\n# prior parameters\nmu    <- rep(0, p)\nLambda_inv <- diag(rep(1e-06,p))\na     <- 0.1\nb     <- 0.1\nAo    <- N/2 + a\nAs    <- sum(n)/2 + a\n\n# pre-computes\nXtX <- list()\nXtY <- list()\nfor (k in 1:N){\n  XtX[[k]] <- t(X[[k]])%*%X[[k]]\n  XtY[[k]] <- t(X[[k]])%*%Y[[k]]\n}\nLmu <- Lambda_inv%*%mu\n\ntic()\n# Gibbs Loop\nfor (i in 2:niter){\n  \n  Omega_inv <- diag(1/diag(Omega))\n  \n  # sample deltas\n  for (k in 1:N){\n    M         <- (1/sigma2)*XtY[[k]] + Omega_inv%*%beta\n    V_inv     <- chol2inv(chol((1/sigma2)*XtX[[k]] + Omega_inv))\n    delta[,k] <- V_inv%*%M+t(chol(V_inv))%*%rnorm(p)\n  }\n  \n  # sample beta\n  M     <- Omega_inv%*%rowSums(delta0) + Lmu\n  V_inv <- solve(N*Omega_inv + Lambda_inv)\n  beta  <- V_inv%*%M+t(chol(V_inv))%*%rnorm(p)\n  \n  # sample omegas\n  for (j in 1:p){\n    Bo <- sum((delta[j,] - beta[j])^2)/2 + b\n    Omega[j,j] <- 1/rgamma(1, Ao, Bo)\n  }\n  \n  # sample sigma2\n  SSE <- 0\n  for (k in 1:N){\n    SSE <- SSE + sum((Y[[k]] - X[[k]]%*%delta[,k])^2)\n  }\n  Bs <- SSE/2 + b\n  sigma2 <- 1/rgamma(1, As, Bs)\n  \n  # store everything\n  keep_delta[,,i] <- delta\n  keep_beta[i,]   <- beta\n  keep_Omega[i,]  <- diag(Omega)\n  keep_sigma2[i]  <- sigma2\n}\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n20.45 sec elapsed\n```\n:::\n:::\n\n::: {.cell hash='index_cache/html/unnamed-chunk-4_788098ee2f636cb77bb503592644d98b'}\n\n```{.r .cell-code  code-summary=\"Construct Trace Plots\"}\nwin <- 1:niter\n\npar(mfrow = c(2,2))\n\nfor (k in 1:p){\n  plot(win, keep_beta[win,k], type = \"l\",\n       ylab = bquote(beta[.(k)]),\n       xlab = \"iter\")\n  abline(h = beta0[k], col = \"red\")\n}\n\nfor (k in 1:p){\n  plot(win, keep_Omega[win, k],   type = \"l\",\n       ylab = bquote(omega[.(k)]^2),\n       xlab = \"iter\")\n  abline(h = Omega[k,k], col = \"red\")\n}\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code  code-summary=\"Construct Trace Plots\"}\npar(mfrow = c(1,1))\n\nplot(win, keep_sigma2[win],   type = \"l\",\n     ylab = bquote(sigma^2),\n     xlab = \"iter\")\nabline(h = sigma20, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-2.png){width=672}\n:::\n:::\n\n::: {.cell hash='index_cache/html/unnamed-chunk-5_3c702d25b3abd85ec6595bb374002ad4'}\n\n```{.r .cell-code  code-summary=\"Construct Trace Plots\"}\nwin <- 1:niter\n\npar(mfrow = c(2,2))\nparam_sample <- sample(1:100,4)\n\nfor (i in param_sample){\n  subscr <- paste0(\"1,\",i)\n  plot(win, keep_delta[1,i,win], type = \"l\",\n       ylab = bquote(delta[.(subscr)]),\n       xlab = \"iter\")\n  abline(h = delta0[1,i], col = \"red\")\n}\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code  code-summary=\"Construct Trace Plots\"}\nparam_sample <- sample(1:100,4)\n\nfor (i in param_sample){\n  subscr <- paste0(\"2,\",i)\n  plot(win, keep_delta[2,i,win], type = \"l\",\n       ylab = bquote(delta[.(subscr)]),\n       xlab = \"iter\")\n  abline(h = delta0[2,i], col = \"red\")\n}\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\nOkay, this appears to be working as well based on the trace plots alone. In the next step we will add a linear trend to the underlying distribution for $\\boldsymbol\\delta_i$.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}